{\rtf1\ansi\ansicpg1252\cocoartf949\cocoasubrtf540
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww12780\viewh12000\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\ql\qnatural\pardirnatural

\f0\b\fs28 \cf0 Guide to the Pass Structure in the DPJ Compiler\
Rob Bocchino\
September 12, 2009
\b0 \
\
The DPJ compiler (
\b dpjc
\b0 ) is based on Sun's 
\b javac
\b0  compiler infrastructure.  In general, javac is well engineered, easy to understand, and easy to modify.  One area in which it is deficient, however, is that it does not have a proper pass manager.  Instead, the pass structure is coded up in an ad-hoc manner using function composition that makes it awkward to add new passes.  It also looks a bit like spaghetti.  Fortunately, though, the current pass structure isn't very complicated, so it's still reasonably easy to understand.\
\
The file that lays out the pass structure is \
\

\b 	src/share/classes/com/sun/tools/javac/main/JavaCompiler.java.\

\b0 \
The 
\b compile
\b0  method (line 802) takes a list of Java files.  In lines 822-826, it parses the files.  Once parsing is done, the input classes are all in AST form.  The AST is defined in\
\

\b 	src/share/classes/com/sun/tools/javac/tree/JCTree.java.\

\b0 \
As usual in an object-oriented compiler implementation, there is a separate class (an inner class of 
\b JCTree
\b0 )  for each kind of AST node.  All steps after parsing are done on the AST representation; 
\b javac
\b0  uses no other internal representation for its passes.\
\
After parsing, 
\b compile
\b0  does 
\b enterTrees
\b0  on the ASTs for the classes (which enters all the global symbols generated by each class), then does 
\b processAnnotations
\b0  on them (which processes Java annotations of the form 
\b @annotation
\b0 ).  If DPJ code generation is turned on (I believe we made this the default for 
\b dpjc
\b0 , unless 
\b -seq
\b0  is specified on the command line), then  
\b makeHarness
\b0  is interposed between parsing and 
\b enterTrees
\b0 .  This step is DPJ-specific; it generates some harness code that is necessary to support the parallel runtime (e.g., starting up worker threads at the beginning of the execution, so they are available when a 
\b foreach
\b0  or 
\b cobegin
\b0  is encountered).\
\
After all this is done, the 
\b compile2
\b0  function (defined starting at line 842) is invoked in line 829.  This function has a switch statement that supports various compile policies.  The default policy, which we use, is "by todo" (the last one).  Line 869 marches through the 
\b todo
\b0  list (generated in the 
\b enterTrees
\b0  step) and does the following steps on each one: attribute (type checking and annotating the AST nodes with their types), check effects (make sure that each method's declared effects cover its actual effects), flow (some simple dataflow analysis, e.g., to make sure all variables are initialized), desugar (desugaring some Java constructs, such as turning 
\b for (T x : y)
\b0  into an ordinary for loop), and code generation (in our case, spitting source code back out).  \
\
In 
\b dpjc
\b0 , the following phases are modified from ordinary 
\b javac
\b0 :\
\
1. The attribution phase extends
\b  javac
\b0 's attribution to do (1) attribution of region declarations and region path lists; (2) attribution of effect summaries; and (3) type checking of enhanced DPJ types with region and effect parameters and RPL and effect arguments.\
\
2. The check effects phase is entirely new and enforces the requirement of the DPJ type and effect system that a method's effect summary cover all its actual effects.\
\
3. Source code generation is extended to generate parallel code using calls to the 
\b ForkJoinTask
\b0  library.  We have implemented this code generation in the "pretty printer," i.e., we do code generation as source printing using the class \
\

\b 	src/share/classes/com/sun/tools/javac/tree/Pretty.java\

\b0 \
If you look in there, you will see print statements that generate the classes and library invocations needed to convert 
\b cobegin
\b0  and 
\b foreach
\b0  into 
\b ForkJoinTask
\b0  calls.  A more robust solution would be to transform the AST first (the way 
\b javac
\b0  does, e.g., generic erasure), but this would involve a fair amount of slightly painful coding that we decided to avoid in the interest of getting things working.  The hacked-up pretty printer is not that bad.  In the process of doing this work, we also fixed some bugs in the 
\b javac
\b0  pretty printer that showed up when Stephen compiled the Collision Tree benchmark.\
\
}