{\rtf1\ansi\ansicpg1252\cocoartf1038\cocoasubrtf250
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww13460\viewh15120\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\ql\qnatural\pardirnatural

\f0\b\fs24 \cf0 Current limitations of DPJ STM code generation
\b0 \
\
Methods that are transitively callable within an atomic block (or a nonint block, when those are implemented) need to have a @Clone annotation (defined in DPJRuntime.Clone).  This isn't fully checked; in particular, you can get code that compiles but doesn't behave correctly if a method without a @Clone annotation overrides a method with a @Clone annotation.\
\
Interfering accesses to local variables within a foreach_nd or cobegin_nd construct are not supported and can cause incorrect behavior.\
\
Fields of inner classes cannot be accessed transactionally.  If an inner class has a field with the same name as a field of an outer class that it extends, then the code may compile but behave incorrectly.\
\
Checked exceptions thrown out of an atomic block are wrapped in a RuntimeException, rather than thrown directly.\
Workaround:\
\pard\pardeftab720\ql\qnatural
\cf0 	try \{\
		atomic \{\
			// May throw checked exception\
		\}\
	\}\
	catch(RuntimeException e) \{\
		if ([e's cause is an exception I care about]) \{\
			[handle it]\
		\} else \{\
			throw e;\
		\}	\
	\}\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\ql\qnatural\pardirnatural
\cf0 \
\
Field accesses in initializer blocks and field initializers (other than to the fields of the object being initialized) are not tracked by the STM system and can cause incorrect behavior.  If a class has any constructors with a @Clone annotation (meaning that a new object of this class can be created within an atomic block), then it and all its parent classes should have no such field accesses in their initializers.\
\
Using break or continue statements to transfer control from inside an atomic block to outside it does not work properly.\
Workaround:  (Note that the "break atomicBlockBody;" statement doesn't actually break out of the atomic block, so it's OK.)\
\pard\pardeftab720\ql\qnatural
\cf0 	boolean breakFlag = false;\
	atomic\
		atomicBlockBody: \{\
			...\
			breakFlag = true;\
			break atomicBlockBody;\
			...\
		\}\
	if (breakFlag) \{\
		break;\
	\}\
\
Assigning to final fields within an atomic block (in a constructor) doesn't work.\
}