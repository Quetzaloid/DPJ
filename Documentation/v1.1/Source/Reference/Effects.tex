\section{Effects%
\label{sec:effects}}
\cutname{effects.html}

Effects are the way that DPJ tracks accesses to the heap to enforce
determinism.  An effect is an action that reads or writes memory.
Every statement and expression in the program is assigned an effect.
If the effects of two statements do not interfere, then the statements
may be safely run in parallel.  Effects don't interfere if neither one
writes to memory, or they operate on different parts of memory, or
they are both invocations of a method declared \kwd{commutative}
(\S~\ref{sec:classes:methods:commutative}).

This section describes how effects work in DPJ.
\S~\ref{sec:effects:basic} describes \emph{basic effects}, which are
individual actions involving memory (such as reading or writing a
variable).  \S~\ref{sec:effects:summaries} describes \emph{effect
  summaries}, which are the program representation of sets of basic
effects, and are used to summarize the effects of methods.
\S~\ref{sec:effects:local} describes \emph{local effects}, which are
effects inside a method that are not visible to the caller and so may
be omitted from the method's effect summary.
\S~\ref{sec:effects:stmt-exp} explains how DPJ statements and
expressions generate basic effects.  \S~\ref{sec:effects:coarsening}
describes \emph{effect coarsening}, which is necessary for summarizing
effects on RPLs and local variables that can go out of scope.
\S~\ref{sec:effects:subeffects} explains the \emph{subeffect} relation
on effects, which is important for checking method effect summaries
against the actual method effects.  \S~\ref{sec:effects:nonint}
explains the \emph{noninterference} relation on effects, which is
important for checking that pairs of parallel tasks have no
conflicting operations.

\subsection{Basic Effects%
\label{sec:effects:basic}}
\cutname{effects.basic.html}

A basic effect is an action involving memory.  DPJ's effect system
represents the following kinds of effects:
%
\begin{enumerate}
%
\item \ithead{Read effects} A read effect indicates a read operation
  on an RPL (\S~\ref{sec:rpls}) or local variable.  Such an effect
  summarizes one or more reads to one or more memory locations
  associated with the region or regions named by the RPL.
%
\item \ithead{Write effects} A write effect indicates a write operation
  on an RPL (\S~\ref{sec:rpls}) or local variable.  Such an effect
  summarizes one or more writes \emph{or reads} to one or more memory
  locations associated with the region or regions named by the RPL.
%
\item \ithead{Invocation effects} An invocation effect indicates an
  invocation of some method, causing some set of basic effects (the
  effects of invoking the method).  The basic effects associated with
  the invocation are called the \emph{underlying effects} of the
  invocation.  For example, if method \kwd{m} has effect summary
  \kwd{writes r} (\S~\ref{sec:effects:summaries}), then invoking
  \kwd{m} generates an invocation effect with \kwd{m} as its method
  and \kwd{writes r} as its underlying effect.
%
\end{enumerate}

Read and write effects on an RPL $R$ are generated by directly
accessing a class field declared to be in $R$
(\S~\ref{sec:classes:field-region-spec}) or an array cell in $R$
(\S\S~\ref{sec:classes:array} and~\ref{sec:types:array}), or by
invoking a method with the effect in its effect summary
(\S~\ref{sec:classes:methods:summaries}).  Invocation effects are
always generated by invoking methods.  \S~\ref{sec:effects:stmt-exp}
gives more details on how DPJ statements and expressions generate
these effects.

Invocation effects are necessary because some method invocations can
commute with others (\S~\ref{sec:classes:methods:commutative}).  To
keep track of these pairs of commuting methods, the compiler needs to
record the information about which method was invoked, in addition to
what effects the method invocation caused.

Notice that effects on local variables (including method parameters)
are recorded separately from effects on RPLs.  Because local variables
cannot have their references taken, and never alias, the compiler
automatically keeps track of interfering effects on local variables.
The programmer doesn't have to put them in RPLs or summarize their
effects.

Finally, notice that a write effect can represent both reads and
writes.  Writes are ``stronger'' than reads (for interference, at
least one of two operations to the same location must be a write), so
it is sound but conservative to represent reads as writes.  In some
cases it may also reduce the size of the effect set.  For example, a
read and a write to the same location may be represented with just the
write effect.  Finally, allowing write effects to represent reads does
not sacrifice any precision, since (1) a read to a location alone can
always be represented as a read effect; and (2) a read and write to a
location can always be represented as a single write to that location
without any loss of precision (the presence of the write already
causes any parallel access to the location to interfere, so the
presence or absence of the read makes no difference).

\subsection{Effect Summaries%
\label{sec:effects:summaries}}
\cutname{effects.summaries.html}

An \emph{effect summary} is a bit of program text that summarizes a
set of basic effects (\S~\ref{sec:effects:basic}).  In the current DPJ
language, effect summaries can appear in the program text only in
method definitions, where they summarize the effects of invoking the
method (\S~\ref{sec:classes:methods:summaries}).  It is anticipated
that future versions of DPJ will also allow effect summaries to appear
as arguments to \emph{effect variables} in class types and method
invocations, for greater flexibility in specifying and checking
effects.

An effect summary consists of one of the following:
%
\begin{enumerate}
%
\item \kwd{pure}, indicating no effect on the heap.
%
\item \kwd{reads} \emph{rpl-list}, indicating reads to the RPLs given
  in \emph{rpl-list}.
%
\item \kwd{writes} \emph{rpl-list}, indicating writes \emph{or reads}
  to the RPLs given in \emph{rpl-list}.  
%
\item \kwd{reads} \emph{rpl-list-1} \kwd{writes} \emph{rpl-list-2},
  indicating both reads to the RPLs in \emph{rpl-list-1} and writes to
  the RPLs in \emph{rpl-list-2}.
%
\end{enumerate}
%
Currently there is no way to represent an invocation effect
(\S~\ref{sec:effects:basic}) directly in an effect summary;
invocations in the method body must be summarized by giving their
underlying effects.  This may change in future versions of DPJ.

Here is a simple example of an effect summary:
%
\begin{numbereddpjlisting}
class Point<region R> {
  int x in R, y in R;
  <region Rp>void add(Point<region Rp> p) 
    reads Rp 
    writes R 
  {
    this.x += p.x;
    this.y += p.y;
  }
}
\end{numbereddpjlisting}
%
This class defines a simple \kwd{Point} object with integer
coordinates \kwd{x} and \kwd{y}.  There is one class region parameter
\kwd{R} (\S~\ref{sec:classes:params:class}), and the coordinate fields
are placed in the region of \kwd{R}.  The \kwd{add} method takes a
\kwd{Point} object with some other (possibly different) region
\kwd{Rp} and adds the coordinates of that point to the coordinates of
this one.  The summarized effects are \kwd{reads Rp writes R}, shown
in line 4, because the method reads the coordinates of \kwd{p} in
region \kwd{Rp} and writes the coordinates of \kwd{this} in region
\kwd{R}.

\subsection{Local Effects%
\label{sec:effects:local}}
\cutname{effects.local.html}

A basic effect (\S~\ref{sec:effects:basic}) is \emph{local} if it is a
read or write effect on a local variable or local RPL
(\S~\ref{sec:rpls:local}), or it is an invocation effect whose
underlying effects are all local.  Local effects are contained within
a method scope and never seen by the calling context, so they may be
ignored when summarizing method effects.  For example:
%
\begin{dpjlisting}
class LocalEffects<region R> {
  int x in R;
  // method has no effects visible to the caller
  void method() 
    pure 
  {
    region r;
    // Write effect on var is local
    LocalEffects<r> var = new LocalEffects<r>();
    // Write effect on region r is local
    var.x = 5;
  }
}
\end{dpjlisting}

\subsection{Effects of Statements and Expressions%
\label{sec:effects:stmt-exp}}
\cutname{effects.stmt-exp.html}

At the heart of DPJ's determinism checking is an analysis of the
effect of every statement and expression in the program.  To compute
the effects, the compiler uses the following information:
%
\begin{itemize}
%
\item The form of the expression or statement.  For example,
  an assignment statements generates a write on the left-hand side,
  and a read on the right-hand side.
%
\item The type of a field access receiver, method invocation receiver,
  or array, together with the RPL of the field (for field access) or
  declared method efects (for method invocations).  For example, if a
  class \kwd{C<region R>} has a field \kwd{x in R}, then access
  through a variable of type \kwd{C<r>} generates an effect on
  \kwd{r}.  Similarly, if \kwd{C} has a method \kwd{void m() writes
    R}, then invoking \kwd{m} on a variable of type \kwd{C<r>}
  generates the effect \kwd{writes r}.
%
\end{itemize}
%
The field region specifiers (\S~\ref{sec:classes:field-region-spec})
are important because they effectively partition the class fields into
regions that can be used to describe the effects.  The method effect
summaries (\S~\ref{sec:classes:methods:summaries}) are important
because they (1) document the effects of methods at API boundaries
(including, e.g., methods in classes for which the source code is not
available); and (2) allow the compiler to infer the effect of a method
invocation from the summary, rather than doing an interprocedural
analysis.  (Because method calls can be recursive, this analysis would
need to iterate to a fixed point.)

In more detail, here is how the compiler computes the effects of a
DPJ statement or expression:

\bfhead{Field access} For field access expressions
\emph{receiver-exp}\kwd{.}\emph{field-name} that directly access a
non-\kwd{final} field, the compiler first computes the RPL accessed by
the expression.  It uses the same procedure as for typing field access
(\S~\ref{sec:types:exp:field}), except that it uses the RPL specifier
of the field (\S~\ref{sec:classes:field-region-spec}) instead of the
type associated with the field, and there are no substitutions for
type parameters in step 4(a).  The compiler records a write or read
effect (\S~\ref{sec:effects:basic}) to the RPL so computed, depending
on whether the expression appears on the left-hand side of an
assignment, or in a read access.

Reads of fields declared \kwd{final} generate no effect (writes, other
than initialization, are not allowed).  Because the value of
a \kwd{final} field does not change after initialization, reading it
cannot cause a conflicting access.

\bfhead{Array access} For array access expressions \kwd{$e_1$[$e_2$]}
that access an array cell, the compiler first computes the RPL of the
cell.  To do this it substitutes $e_2$ for the leftmost index variable
in the leftmost RPL argument appearing in the type of $e_1$.  For
example, if array \kwd{A} has type \kwd{int[]<[\_]>}, then the RPL
accessed by \kwd{A[0]} is \kwd{[i]}; and if array \kwd{B} has type
\kwd{int[]<[i]>\#i[]<[i]:[j]>\#j}, then the RPL accessed by \kwd{B[0]}
is \kwd{[0]}.  The compiler records a write or read effect to the RPL
so computed, depending on whether the array access expression appears
on the left-hand side of an assignment, or in a read access.

Note that access through multiple dimensions of an array of arrays
causes a read effect for all but the last dimension.  For example, for
array \kwd{B} defined above, the effect of expression \kwd{B[0][1]} is
a read of \kwd{[0]}, plus a either a read or write on \kwd{[0]:[1]},
depending on the context.  For example, \kwd{x = B[0][1]} generates a
read, while \kwd{B[0][1] = x} generates a write.  In fact, this is
just a special case of the rules stated in the previous paragraph,
together with the rules for compound expressions (see below).

\bfhead{Method invocation} For method invocation expressions, the
compiler computes and accumulates the effects of evaluating the
receiver and argument expressions as described in this section.  Then
it uses the method's effect summary
(\S~\ref{sec:classes:methods:summaries}) to compute the effect of the
invocation itself.  It uses the same procedure as for computng the
return type of a method (\S~\ref{sec:types:exp:invoke}), except that
it uses the effect summary instead of the declared return type, and
there are no substitutions for type parameters in steps 4(a) or 4(b).
The compiler records an invocation effect (\S~\ref{sec:effects:basic})
with the invoked method and the computed effect.

\bfhead{Local variable access}  For statements and expressions that
access a non-\kwd{final} local variable (i.e., variable declared in a
method scope or method formal parameter), the compiler records a read
or write effect on the variable.  Effects on \kwd{final} local
variables are ignored.

\bfhead{Compound statements and expressions} For any statement or
expression made up of other statements or expressions (including, for
example, an assignment that has a method invocation on its right-hand
side, or an array access to an expression which is itself an array
access), the compiler accumulates the effect of the components,
coarsening component effects as necessary
(\S~\ref{sec:effects:coarsening}) to remove elements that are no
longer in scope at the outer level.



\subsection{Effect Coarsening%
\label{sec:effects:coarsening}}
\cutname{effects.coarsening.html}

A statement or expression may generate an effect that is no longer in
scope where the effect must be reported.  For example, consider the
following \kwd{foreach} loop (\S~\ref{sec:parallel:foreach}) on an
index-parameterized array (\S~\ref{sec:classes:array:ipa}):
%
\begin{numbereddpjlisting}
arrayclass ArrayInt { int in [index]; }
ArrayInt A = new ArrayInt(N);
foreach (int i in 0, N) {
  A[i] = i;
}
\end{numbereddpjlisting}
%
In line 3, the effect is \kwd{writes [i]}.  But what is the effect in
the scope outside the loop?  This is important, for example, if this
code appears inside a method body and its effect must be summarized.
We can solve this problem with partially-specified RPLs
(\S~\ref{sec:rpls:partial}).  For example, the effect \kwd{writes [?]}
covers all the effects \kwd{writes [i]} for all \kwd{i} inside the
loop, so that is what we use.  This is called \emph{effect
  coarsening}.

\bfhead{Coarsening of local effects} An effect on a local RPL
(\S~\ref{sec:rpls:local}) or local variable is simply deleted from the
effect set when the RPL or variable goes out of scope.  For example,
in the following code fragment, neither block contained in the
\kwd{cobegin} has any effect:
%
\begin{dpjlisting}
class LocalEffectCoarsening<region R> {
  int x in R;
  void method() 
    pure 
  {
    cobegin {
      // No effect here because var1 and r1 are out of scope
      {
        region r1;
        LocalEffectCoarsening<r1> var1 = 
          new LocalEffectCoarsening<r1>();
        var1.x = 10;
      }
      // No effect here either because var2 and r2 are out of scope
      {
        region r2;
        LocalEffectCoarsening<r2> var2 =
          new LocalEffectCoarsening<r2>();
        var2.x = 25;
      }
    }
  }    
}
\end{dpjlisting}

This pattern can also be used effectively with \kwd{foreach}, by
having each iteration create its own objects whose effects are
invisible to the other iterations:
%
\begin{dpjlisting}
foreach (int i in 0, N) {
  // r is local to a foreach iteration
  region r;
  // Do some effects on r
  ...
}
\end{dpjlisting}
%
This technique is useful for creating private objects in each
iteration that manipulate data local to that iteration.  See
\tutorial\ for more examples.

\bfhead{Coarsening of nonlocal effects} Coarsening of nonlocal
effects works as follows.

\ithead{Variable RPLs} An effect on an RPL starting with a
\kwd{final} local variable
(\S\S~\ref{sec:rpls:basic:var},~\ref{sec:rpls:sequences}) is coarsened
when the variable goes out of scope.  The effect is replaced by a new
effect on \emph{owner-rpl}\kwd{:*}, where \emph{owner-rpl} is the
owner RPL of the variable's type (\S~\ref{sec:types:class:owner-rpl}).
Because variables may be nested under variables, this operation is
performed recursively on the resulting RPL until an RPL is obtained
that is valid in the outer scope.

For example:
%
\begin{dpjlisting}
class VariableCoarsening<region R> {
  int x in R;
  void method() 
    writes R:* 
  {
    // Coarsened effect is 'writes R:*'
    {
      final VariableCoarsening<R> vc1 = 
        new VariableCoarsening<R>();
      VariableCoarsening<vc1> vc2 =
        new VariableCoarsening<vc1>();
      // Effect is 'writes vc1'
      vc2.x = 5;
    }
  }
}
\end{dpjlisting}

Note that method parameters are in scope in the method definition, so
effects on method parameter RPLs don't need to be coarsened in the
method's effects:
%
\begin{dpjlisting}
abstract class ParamRPLs<region R> {
  abstract void method(ParamRPLs<R> param)
    // OK; 'writes R:*' is also OK, but less precise
    writes param;
}
\end{dpjlisting}

\ithead{Array index RPLs} An effect on an RPL containing the array
index \kwd{[$e$]} is coarsened to \kwd{[?]} if the expression $e$
includes an integer variable that goes out of scope.  An example is
the \kwd{foreach} code given at the beginning of this section.

\subsection{Subeffects%
\label{sec:effects:subeffects}}
\cutname{effects.subeffects.html}

The subeffect relation determines whether one set of effects covers
another set of effects, i.e., all effects in the second set are
represented in the first set.  The compiler uses the subeffect
relation to check that a method's declared effects
(\S~\ref{sec:classes:methods:summaries}) include the actual effects of
its body and the effects of any overriding methods.

\bfhead{Basic effects}  The following rules determine when one basic
effect (\S~\ref{sec:effects:basic}) is a subeffect of another:
%
\begin{itemize}
%
\item If one RPL is included in another
  (\S~\ref{sec:rpls:comparing:include}), then a read of the first RPL
  is a subeffect of a read or write to the second.  For example,
  \kwd{reads Root} is a subeffect of \kwd{reads Root:*} and
  \kwd{writes Root:*}.
%
\item If one RPL is included in another, then a write to the first RPL
  is a subeffect of a write to the second.  For example, \kwd{writes
    Root} is a subeffect of \kwd{writes Root:*}.  Note that
  \kwd{writes Root} is \emph{not} a subeffect of \kwd{reads Root:*}.
%
\item An invocation of method $m$ with underlying effect set $E_1$ is
  a subeffect of an invocation of method $m$ with underlying effect
  set $E_2$ if $E_1$ is a subeffect of $E_2$.  For example, an
  invocation of $m$ with underlying effect \kwd{writes R} is a
  subeffect of an invocation of $m$ with underlying effect \kwd{writes
    R:*}.
%
\end{itemize}

\bfhead{Effect sets}  The following rules determine when one set of
basic effects is a subeffect of another:
%
\begin{itemize}
%
\item If each basic effect in one set is a subeffect of some basic
  effect in the another set, then the first set is a subeffect of the
  second.  For example, \kwd{reads A writes B} is a subeffect
  \kwd{writes A:*, B:*}, because \kwd{reads A} is a subeffect of
  \kwd{writes A:*}, and \kwd{writes B} is a subeffect of \kwd{writes
    B:*}.
%
\item An invocation effect is a subeffect of its underlying effect.
  For example, an invocation of method $m$ with the effect \kwd{writes
    R} is a subeffect of \kwd{writes R}.  This means that invocations
  may always be summarized by stating their underlying effects.
%
\end{itemize}

\subsection{Noninterference of effect%
\label{sec:effects:nonint}}
\cutname{effects.nonint.html}

The noninterference relation on effects determines whether two sets of
effects are safe to be run in parallel.  The compiler uses the
noninterference relation to check that there are no conflicting
effects in mutually parallel tasks (\S~\ref{sec:parallel}).

\bfhead{Basic effects}  The following rules determine when one basic
effect (\S~\ref{sec:effects:basic}) is a subeffect of another:
%
\begin{itemize}
%
\item Two basic effects are noninterfering if they are both read
  effects.
%
\item Two basic effects are noninterfering if they are each read or
  write effects, and they operate on disjoint RPLs
  (\S~\ref{sec:rpls:comparing:disjoint}).
%
\item Two invoke effects are noninterfering if they invoke the same
  method, and the method is declared \kwd{commutative}
  (\S~\ref{sec:classes:methods:commutative}).
%
\end{itemize}

\bfhead{Effect sets}  The following rules determine when one effect
set is a subeffect of another:
%
\begin{itemize}
%
\item If every basic effect in one set is noninterfering with every
  basic effect in another set, then the two sets are noninterfering.
  For example, \kwd{reads A writes B} is noninterfering with
  \kwd{writes C,D}.  However, \kwd{reads A writes B} is interfering
  with \kwd{writes A,C}, because \kwd{reads A} inteferes with
  \kwd{writes A}.
%
\item If two effect sets are each a subeffect of another effect set,
  and the including sets are noninterfering, then the included sets
  are noninterfering.  In particular, two invoke effects are
  noninterfering if their underlying effects are (because the
  underlying effects include the invoke effects, see
  \S~\ref{sec:effects:subeffects}).
%
\end{itemize}
