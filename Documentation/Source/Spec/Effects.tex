\section{Effects}
\label{section:effects}

An effect is a set of actions that affect memory.  Every statement and
expression in the program is assigned an effect.  If the effects of
two statements do not interfere, then the statements may be safely run
in parallel.

\subsection{Basic Effects}
\label{section:effects:basic}

Internally, the compiler represents effects as sets of \emph{basic
  effects}.  A basic effect is one of the following:
%
\begin{enumerate}
%
\item A \emph{read effect}, indicating a read operation on an RPL
  (\S~\ref{section:rpls}) or stack region
  (\S~\ref{section:regions:stack}).  This effect represents any read at
  runtime to any heap region named by the RPL, or to the stack region.
%
\item A \emph{write effect}, indicating a write operation on an RPL or
  stack region.  This effect represents any read or write to any heap
  region named by the RPL, or to the stack region.
%
\item An \emph{invoke effect}, indicating an invocation of method $m$
  of class $C$ with effect $E$, where $E$ is a set of basic effects.
%
\end{enumerate}
%
A basic effect is \emph{local} if it is a read or write effect on a
stack region or an RPL containing a local region name
(\S~\ref{section:rpls:elts:name-elts}), or it is an invocation effect
whose underlying effects are all local.  We refer to a set of basic
effects as an \emph{effect set}.


\subsection{Effect Summaries}
\label{section:effects:summaries}

The programmer may specify an effect summary as part of a method
definition (\S~\ref{section:class-def:methods:effect-summaries}).  An
effect summary consists either of the keyword \kwd{pure}, representing
an empty effect set, or one or both of the following, in this order:
%
\begin{itemize}
%
\item \emph{Read effects:} The keyword \kwd{reads}, followed by a
  comma-separated list of valid RPLs (\S~\ref{section:rpls}),
  representing one read effect on each RPL.
%
\item \emph{Write effects:} The keyword \kwd{writes}, followed by a
  comma-separated list of valid RPLs (\S~\ref{section:rpls}),
  representing one write effect on each RPL.
%
\end{itemize}
%
The effect set of the whole summary is the union of zero, one, or two
effect sets generated as described above.

\subsection{Effect Inference}
\label{section:effects:inference}

The compiler infers the effects of a statement, expression, or
statement block by using the following method-local analysis:
%
\begin{itemize}
%
\item For expressions \emph{selector-exp}\kwd{.}\emph{field-name} that
  directly access a non-\kwd{final} field (effects on \kwd{final}
  fields are ignored), the compiler computes the RPL \emph{access-rpl}
  accessed by the expression.  It uses the same procedure as for
  typing field access expressions
  (\S~\ref{section:types:exp:field}), except that it uses the
  the RPL specifier (\S~\ref{section:class-def:fields}) instead of the
  type associated with \emph{field-name} in the class $C$, and there
  are no substitutions for type parameters.  The compiler records a
  read or write effect (\S~\ref{section:effects:basic}) to
  \emph{access-rpl}, depending on whether the expression is used in an
  assignment or access.
%
\item For statements and expressions that invoke a method, the
  compiler computes the effect set $E$ generated by the invocation.
  It uses the same procedure as for typing method invocation
  expressions (\S~\ref{section:types:exp:invocation}), except that it
  uses the effect summary of the method
  (\S~\ref{section:class-def:methods:effect-summaries}) instead of the
  return type, and there are no substitutions for type parameters.
  The compiler records an invocation effect
  (\S~\ref{section:effects:basic}) with the method symbol and $E$.
%
\item For statements and expressions that access a non-\kwd{final}
  stack variable (i.e., method formal parameter or local variable),
  record a read or write effect on a stack region identified by the
  variable's symbol.  Effects on \kwd{final} variables are ignored.
%
\item For any other statement or expression, the compiler accumulates
  the effects of its components, coarsening component effects as
  necessary (\S~\ref{section:effects:coarsening}) to generate effects
  that are valid at the outer scope.
%
\end{itemize}
%

\subsection{Effect Coarsening}
\label{section:effects:coarsening}

\noindent
\textbf{Coarsening of RPLs:} RPLs appearing in accumulated effects may
include any of the following elements that are no longer in scope at
the point where the effects are being reported: (1) integer variables;
(2) \kwd{final} local variables of class type; and (3) locally
declared region names.  The compiler therefore performs the following
conversion (called \emph{effect coarsening}) to generate a valid set
of accumulated effects in the surrounding environment:
%
\begin{itemize}
%
\item Delete all effects on RPLs containing a local region name that
  is out of scope.
%
\item Replace each RPL \emph{rpl} that starts with \emph{var}, where
  \emph{var} is a \kwd{final} local variable not in scope, with
  \emph{owner-rpl}\kwd{:*}, where \emph{owner-rpl} is the owner RPL
  (\S~\ref{section:types:class:owner-rpls}) of the type of \emph{var}.
  Perform this operation recursively on the resulting RPL.
%
\item Replace all elements \kwd{[}$e$\kwd{]}, where $e$ refers to
  variables not in scope, with \kwd{[?]}.
%
\end{itemize}

\noindent
\textbf{Coarsening of Stack Regions:} If a stack region appearing in
an effect goes out of scope, any effect on that stack region is
deleted in translating the effect to the outer scope.

\subsection{Subeffects}
\label{section:effects:subeffects}

The following rules determine whether effect set $E_1$ is a subeffect of
effect set $E_2$:
%
\begin{enumerate}
%
\item If $E_1$ and $E_2$ each consist of a single basic effect, then
  the following rules apply: (a) if $R_1$ is included in $R_2$
  (\S~\ref{section:rpls:relations:inclusion}), then a read of $R_1$ is
  a subeffect of a read or write of $R_2$, and a write of $R_1$ is a
  subeffect of a write of $R_2$; and (b) if $E_3$ is included in
  $E_4$, then an invocation of method $M$ with effect $E_3$ is a
  subeffect of an invocation of the same method $M$ with effect $E_4$.
%
\item An invocation of method $M$ with effect $E$ is a subeffect of $E$.
%
\item If $E_1$ is a subset of $E_2$ (i.e., all the basic effect of
  $E_1$ also appear in $E_2$), then $E_1$ is a subeffect of $E_2$.
%
\item If $E_1 = E_3 \cup E_4$, where $E_3$ and $E_4$ are subeffects of
  $E_2$, then $E_1$ is a subeffect of $E_2$.
%
\item The subeffect relation is reflexive and transitive.
%
\end{enumerate}


\subsection{Noninterfering Effects}
\label{section:effects:noninterference}

The following rules determine whether effect sets $E_1$ and $E_2$ are
noninterfering:
%
\begin{enumerate}
%
\item If $E_1$ and $E_2$ each consist of a single basic effect, then
  the following rules apply: (a) two read effects are noninterfering;
  (b) two effects on $R$ and $R'$, each a read or write, are
  noninterfering if $R$ and $R'$ are disjoint
  (\S~\ref{section:rpls:relations:disjoint}); and (c) two invocations
  of the same method are noninterfering if the method is declared
  \kwd{commutative}
  (\S~\ref{section:class-def:methods:commutativity}).
%
\item If $E_3$ and $E_4$ are noninterfering, then an invocation of
  method $M$ with effect $E_3$ is noninterfering with $E_4$.
%
\item If $E_1 = E_3 \cup E_4$, where $E_3$ and $E_4$ are both
  noninterfering with $E_2$, then $E_1$ is noninterfering with $E_2$.
%
\item The noninterference relation is symmetric.
%
\end{enumerate}


